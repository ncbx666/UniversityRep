#include<iostream>
#include<vector>
using namespace std;

// размеры первой и второй доли соответственно

const int n = 6, k = 6;

// Определяем списки смежности для каждой вершины графа
vector < vector<int> > g(n);

// массив для вершин из правой доли. тут храним информацию о том, есть ли у вершины из правой доли смежное ребро из паросочетания
vector<int> match(k, -1);

// массив для вершин из левой доли
vector<bool> used(n, false);

// функция, которая проверяет есть ли увеличивающая цепь из вершины v и использована ли вершина на данном пути
bool try_kuhn(int v) {
	if (used[v])  return false; // если мы знаем, что мы пытались идти из этой вершины и у нас не получилось, то не идем дальше 
	used[v] = true; // запоминаем, что вершина использована
	for (int i = 0; i < g[v].size(); ++i) { // перебираем всех соседей v
		int to = g[v][i]; // записываем текущую смежную вершину
		if (match[to] == -1 || try_kuhn(match[to])) { // если текущая смежная вершина не насыщена, или удаётся найти альтернативный путь, который заканчивается в ненасыщенной вершине
			match[to] = v; // насыщаем вершину из правой доли ребром в v
			return true; // возвращаем успех
		}
	}
	return false; // если найти альтернативный путь не удалось, возвращаем ложь
}

int main() {
	// записываем списки смежности для каждой вершины графа
	g[0] = { 0,1,2,3,4,5 };
	g[1] = { 0,1 };
	g[2] = { 0,2 };
	g[3] = { 0,2,3,4,5 };
	g[4] = { 0 };
	g[5] = { 5 };

	match.assign(k, -1); // изначально никто не посещен
	for (int v = 0; v < n; ++v) { // перебираем вершины из левой доли
		if (try_kuhn(v)) { //если нашли увеличивающую цепь, то сбрасываем все метки вершин
			used.assign(n, false);
		}
	}

	for (int i = 0; i < k; ++i) // выводим все пары вершин, которые мы взяли в паросочетание
		if (match[i] != -1)
			cout<< match[i] + 1 <<' '<< i + 1 << '\n';

	return 0;
}